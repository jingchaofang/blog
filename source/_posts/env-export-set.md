---
title: Shell Env Export Set
date: 2018-11-28 12:21:36
tags:
---

https://dzone.com/articles/what-you-should-know-about-node-env

unix shell的变量分类
在Shell中有三种变量：内部变量,环境变量,用户变量。
内部变量：系统提供，不用定义，不能修改
环境变量：系统提供，不用定义，可以修改,可以利用export将用户变量转为环境变量.
用户变量：用户定义，可以修改
(1)内部变量(系统变量,环境变量,参数变量,预定义变量)
内部变量是Linux所提供的一种特殊类型的变量，这类变量在程序中用来作出判断。在shell程序内这类变量的值是不能修改的。
   表示方法     描述
   $n     $1 表示第一个参数，$2 表示第二个参数 ...
   $#     命令行参数的个数
   $0     当前程序的名称
   $?     前一个命令或函数的返回码
   $*     以"参数1 参数2 ... " 形式保存所有参数
   $@     以"参数1" "参数2" ... 形式保存所有参数
   $$     本程序的(进程ID号)PID
(2) 环境变量
  Linux环境（也称为shell环境）由许多变量及这些变量的值组成，由这些变量和变量的值决定环境外观。这些变量就是环境变量。
包括两部分,一是,由系统设置的,主要包括： HOME,LOGNAME,MAIL,PATH,PS1,PWD,SHELL,TERM
二是,用户在命令行中设置的,使用export命令,但是用户注销时值将丢失
(3)用户变量(私有变量,本地变量)
  在命令行中自己设定的.
set:显示(临时设置)用户变量，包括私有变量和本地变量。存活周期：命令结束。
env:显示(临时设置)用户变量，包括本地变量。存活周期：命令结束。
export:显示(设置)当前导出成用户环境变量的shell变量。存活周期：用户注销。
一般设置和显示用export。


## 概述

Linux是一个多用户的操作系统。每个用户登录系统后，都会有一个专用的运行环境。通常每个用户默认的环境都是相同的，这个默认环境实际上就是一组环境变量的定义。用户可以对自己的运行环境进行定制，其方法就是修改相应的系统环境变量。

环境变量是和Shell紧密相关的，用户登录系统后就启动了一个Shell。对于Linux来说一般是bash，但也可以重新设定或切换到其它的Shell（使用chsh命令）。

根据发行版本的情况，bash有两个基本的系统级配置文件：/etc/bashrc和/etc/profile。这些配置文件包含两组不同的变量：shell变量和环境变量。前者只是在特定的shell中固定（如bash），后者在不同shell中固定。很明显，shell变量是局部的，而环境变量是全局的。环境变量是通过Shell命令来设置的，设置好的环境变量又可以被所有当前用户所运行的程序所使用。对于bash这个Shell程序来说，可以通过变量名来访问相应的环境变量，通过export来设置环境变量。

## 常见的Shell变量

PATH 这个变量包含了一系列由冒号分隔开的目录，系统就从这些目录里寻找可执行文件。如果你输入的可执行文件（例如ls、rc-update或者emerge） 不在这些目录中，系统就无法执行它（除非你输入这个命令的完整路径，如/bin/ls）。  
ROOTPATH 这个变量的功能和PATH相同，但它只罗列出超级用户（root）键入命令时所需检查的目录。  
LDPATH 这个变量包含了一系列用冒号隔开的目录，动态链接器将在这些目录里查找库文件。 
MANPATH 这个变量包含了一系列用冒号隔开的目录，命令man会在这些目录里搜索man页面。  
INFODIR 这个变量包含了一系列用冒号隔开的目录，命令info将在这些目录里搜索info页面。  
PAGER 这个变量包含了浏览文件内容的程序的路径（例如less或者more）。  
EDITOR 这个变量包含了修改文件内容的程序（文件编辑器）的路径（比如nano或者vi）。  
KDEDIRS 这个变量包含了一系列用冒号隔开的目录，里面放的是KDE相关的资料。 
CONFIG_PROTECT 这个变量包含了一系列用空格隔开的目录，它们在更新的时候会被Portage保护起来。 
CONFIG_PROTECT_MASK 这个变量包含了一系列用空格隔开的目录，它们在更新的时候不会被Portage保护起来。

PATH决定了shell将到哪些目录中寻找命令或程序
HOME当前用户主目录
MAIL是指当前用户的邮件存放目录。
SHELL是指当前用户用的是哪种Shell。
HISTSIZE是指保存历史命令记录的条数
LOGNAME是指当前用户的登录名。 
HOSTNAME是指主机的名称，许多应用程序如果要用到主机名的话，通常是从这个环境变量中来取得的。
LANG/LANGUGE：是和语言相关的环境变量，使用多种语言的用户可以修改此环境变量。 
PS1：是基本提示符，对于root用户是#，对于普通用户是$。
PS2：是附属提示符，默认是“>”。

## set env export

set：查看或设置shell变量包括的私有变量以及用户变量，不同类的shell有不同的私有变量 bash,ksh,csh每中shell私有变量都不一样。每个shell有自己特有的变量（set）显示的变量，这个和用户变量是不同的，当前用户变量和你用什么shell无关，不管你用什么shell都在，比如HOME,SHELL等这些变量，

env：查看和设置用户变量变量

export：查看和设置当前导出成用户变量的shell变量。

举个栗子：

shell变量设置：test=123
查看变量的值会看到输出123：echo $test 
查看当前用户变量会看到没有test变量：env | grep test
查看shell变量会看到输出test=123：set | grep test
查看export导出的变量会看没有test变量：export | grep test
这步用export导出一下shell变量变成用户变量：export test
这步再查看下用户变量发现有test了：env | grep test

总结：linux分shell变量(set)，用户变量(env)，shell变量包含用户变量，export是一种命令工具，是显示那些通过export命令把shell变量中包含的用户变量导入给用户变量的那些变量。

使用unset命令来清除环境变量，注意set env  export设置的变量，都可以用unset来清除的

## 本地变量

对当前shell进程有效，除当前shell进程之外的其他进程无效，比如我设定一个本地变量a=1，这个值只在当前用户当前shell有生命周期意义，如果在shell中又开启一个子shell或退出shell重新登录一个shell，那么这个a的变量值就无效了。

显示已定义的所有变量：set。

删除变量：unset 变量名，当我们执行某个程序完成后，最好将变量的删除，以释放内存空间。

## 环境变量

对当前shell以及子shell都有效，登录进程称为父进程，shell中执行的用户称为子进程，不像本地变量只用于当前shell，他能用于所有的子进程，/etc/profile文件中已经设置了一些环境变量。将之放入profile文件意味着每次登录时这些值都将被初始化。所有的环境变量均为大写。环境变量应用于用户进程前，必须使用export命令导出，环境变量与本地变量设置方法相同。

显示已定义的环境变量：printenv, env, export命令查看

清楚环境变量：unset 环境变量名称。

bash有许多内建的环境变量：PATH, SHELL, USRE, UID, HISTSIZE, HOME, PWD, OLDPWD, HISTFILE, PS1。

## 局部变量

对当前shell进程中的某段代码有效，在程序运行期间不是一直存在，而只是在函数执行期间存在，函数的一次调用结束后，变量就会撤销，其所占的内存也会被收回，比如我在脚本里定义个局部变量，当我执行完脚本之后这个局部变量就会被删除。

## 位置变量

$1，$2…来表示，用于让脚本在执行的过程中调用，通过命令行传递参数

## 特殊变量

$? 上个命令的执行状态结果，$?返回0。可以在任何命令或脚本中返回此变量以获得返回信息。基于此信息，可以在脚本中做更进一步的研究，返回0意味着成功，非0为出现错误。

$0 指脚本名本身

$# 传递给脚本参数的个数

$* 以一个单字符串显示所有向脚本传递的参数。与位置变量不同，此选项参数可超过9个。

$@ 与$#相同，但是使用时加引号，并在引号中返回每个参数，两者不加引号表示的意思相同，如果加引号，前者表示的是一个整体，当做一个参数来使用，而后者为多个参数。

$- 显示shell使用的当前选项，与set命令功能相同

$! 后台运行的最后一个进程的进程id号


## 本地变量，环境变量，局部变量之间的区别

三者的影响范围不同，范围从大到小依次是环境变量，本地变量，局部变量，而环境也是全局的，对所有用户都生效，其他两个只针对当前用户有效。

环境变量，传递给子进程的变量，遗传性是环境变量和其他两者之间的差别，只能单向从父进程传递给子进程，不管子进程的环境变量如何变化，都不会影响父进程的环境变量

## 环境变量的配置：

最根本的设置、更改变量的配置文件 ~/.bash_profile ~/.bashrc ~/.bash_logout

~/.bash_profile 用户登录时被读取，其中包含的命令被执行

~/.bashrc 启动新的shell时被读取，并执行

~/.bash_logout shell登录退出时被读取

编辑/etc/profile修改全局环境变量，编辑.bash_profile修改当前用户的环境变量 修改完成之后source一下即可生效，例如source ~/.bash_profile

此外shell(这里指bash)的初始化过程是这样的：

1. bash检查文件/etc/profile是否存在
2. 如果存在，bash就读取该文件，否则跳过
3. bash检查~主目录下的文件.bash_profile是否存在。
4. 如果存在，bash就读取该文件，否则跳过
5. bash检查主目录下的.bash_login是否存在。
6. 如果存在，bash就读取该文件，否则跳过
7. bash检查主目录下的文件.profile是否存在
8. 如果存在，bash就读取该文件，否则跳过。
这些步骤都执行完后，就出现提示符了，ksh默认提示符是$.

### Linux的变量种类
按变量的生存周期来划分，Linux变量可分为两类：

1. 永久的：需要修改配置文件，变量永久生效。

2. 临时的：使用export命令行声明即可，变量在关闭shell时失效。

### 设置变量的三种方法

1. 在/etc/profile文件中添加变量(对所有用户生效，并且永久的)

例如：编辑/etc/profile文件，添加CLASSPATH变量
vi /etc/profile
export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib

注：修改文件后要想马上生效还要运行source /etc/profile不然只能在下次重进此用户时生效。

2. 在用户目录下的.bash_profile文件中增加变量(对当前用户生效，并且永久的)

例如：编辑用户目录（/home/guok）下的.bash_profile
vi /home/guok/.bash.profile
添加如下内容：
export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib

注：修改文件后要想马上生效还要运行source /home/guok/.bash_profile不然只能在下次重进此用户时生效。

3. 直接运行export命令定义变量(只对当前shell有效，临时的)

在shell的命令行下直接使用export变量名=变量值定义变量，该变量只在当前的shell或其子shell下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变量，需要使用的话还需要重新定义。

## 参考
https://my.oschina.net/qihh/blog/89251
https://blog.csdn.net/longxibendi/article/details/6125075

